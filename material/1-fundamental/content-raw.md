Course goals


Turn people into high quality junior web developers that companies will truly want to hire
Allow people to become knowledgeable in both FE and BE, but truly specialized in either one of those with a specific tech stack. This should allow people to outcompete other generic juniors that are ‘fullstack’
Teach about the culture and the mindset of web developers which will make it easier to fit into web development teams and be comfortable even in their first job
Teach core soft skills that will be needed for a successful career as a web developer

Course duration
 ~800 hours total, spending ~20 hours / week for ~10 months.
Course Structure
3 core modules, core module consisting of 5 sprints. A module is expected to take 150-200 hours. Afterwards, specialization modules focusing either on FE or BE and a specific framework, taking ~200 hours each. Learner is expected to choose one.

Many parts will also have ‘directions for further research’ – prompts that are meant to guide a learner towards a more personalized learning experience based on their interests and goals. They are meant to make sure that each learner has the opportunity to also develop their own unique strengths, instead of everyone going through the same identical steps and resources. Each project at the end of the sprint will expect a learner to have done some further research (either based on Turing College prompts or not) – so once you find a topic that interests you, don’t skip it!

A sprint is expected to take 20-40 hours (depending on background knowledge) and 1-2 weeks (depending on background knowledge and time spent per week).


Quiz questions
 https://docs.google.com/spreadsheets/d/1-yXdHZVXJJ05gWZt8ZFG7GYwV6LJKAYv9M6qkjeJiM0/edit#gid=0
Module 1 - Core Programming & Computer Science
Expected module duration: 150-200 hours (7-10 weeks)
Each module 1 project (final part) takes about X hours to complete. There are X total projects in module 1.
Each of the X sprints in module 1 have X non-project parts. Each non-project part takes around X hours to complete.

Module goals








Sprint 1 - First Steps Into Programming
Sprint goals
Get a basic understanding of programming with Python
Get into the right habits for learning
Learn how TC works
Do the first correction and meet an STL.

Part 1: Functions and Variables
Welcome!

Congratulations and welcome to the Turing College Web Development Course!

Web development is by far one of the most versatile career paths these days. You can work in pretty much every single industry, you can work either alone or in teams, and you can choose to work remotely or in an office. The kind of web development that you do can be very different as well – you can focus on complex platforms used by millions of people, or smaller websites for local businesses, or anything in-between. Most web developers, however, specialize based on their interests and strengths:
Front-end development that is responsible for code which creates beautiful interfaces and interactivity for the users;
Back-end development which deals with storing, processing and providing the data to be displayed by the front-end;
Full-stack development that deals with both front-end and back-end.

All of this allows for a great deal of flexibility and the ability to find a niche that aligns with your interests and skills.

While the demand for experienced web developers is consistently high (even in periods of economic slowdown), the hardest part is almost always getting into the industry when you are just starting out. The many benefits of a web development career entices many people to try it, which means that the competition for junior developer positions is high as well.

The goal of Turing College is to give motivated people like you an exceptional learning environment which would make them truly stand-out from the competition once they’ve finished our course. It is not meant to be easy, and it is not meant to be unrealistically quick (you won’t find us promising people that they can become web developers in just a couple of weeks!). Since you have passed our admissions, however, we are confident that you have what it takes to complete this course, become a web developer, and we are very honored to share this journey with you!

Structure of the course
The smallest piece of Turing College material is called a Part, and multiple Parts make up a Sprint. Most Parts have a quiz at the end. The last Parts of each Sprint are different though — they require you to complete a practical project, submit it and schedule 1-1 project review session using our platform. Finally, the largest piece – a collection of sprints – is called a module and covers a large collection of related topics.

In short: Module>Sprint>Part.

Module 1 is called "​​Core programming & Computer Science" and will teach you just that. We will use the Python programming language, and we do not assume any prior programming knowledge. Even if you did do coding before, you will benefit from revising many of the topics here and likely find new ones that will be of great use. By the end of this module, you will feel much more confident in your coding skills which will allow you to continue to learn new programming languages and web-development specific technologies in modules 2 and beyond.

Resources used in this course
CS50 is a series of courses taught in Harvard University which is also provided online. Turing College has been partnering with CS50 and our mentors have been teaching their courses for multiple years now. Like many others, we have found that it is a remarkable resource for learning the basics of programming and computer science, creating an incredibly strong base for multiple specializations of engineering – web development included. Therefore, many of the sprints at Turing College will have CS50 resources at their core.

Besides CS50, this course will be using many other external resources. It is very important to note that you should never need to pay for any of the learning material assigned. If at any point it seems that you need to pay for access to a resource - please contact us either directly through Discord or using the support chat function in the platform.

Why are we using external content?
Like most bootcamps, schools, universities and other educational institutions, we make use of curated external content – such as books, videos, articles, interactive coding platforms and more. The reason for this is that for many topics, there are already great resources out there that have been created by top experts in the world. The difficulty in learning stems not from the lack of content but from finding the right content, which can be extremely difficult due to the sheer amount of various options (far from all of which are of good quality). It is also difficult to structure that content in such a way that you get a full, coherent path towards a successful career. Professional expert knowledge is needed for creating such a structure. Finally, for the vast majority of people, it is extremely beneficial to be in a group with peers and experts working through the same content. This allows you to get help when stuck and to strengthen your own knowledge by helping others.

Turing College aims to provide top-level education by incorporating all of these things — carefully structured content by top professionals in the field together with a community of mentors and peers in which studying this content becomes fully efficient.


What to do if you already know some topics or have previously gone through the given learning material?
We strongly suggest going through the material once more to ensure that you have a good understanding – you might notice that you’ve missed or forgotten something. Even if not, it can be a good refresher. You can also practice being curious (an immensely important trait for developers!) and try to look for more complicated questions inside these resources that you could then explore as part of the "direction for further research" (explained further).

Finally, if you are experienced, be sure to try to help others as much as possible – whether it’s during stand-ups, via Discord or peer corrections. These are great ways to become a part of the learning community and to become qualified for a Junior Team Lead role if it interests you.

Managing time spent on each topic & resource

When going through the resources given, unless noted otherwise, you should try to follow all the instructions in the resource and replicate the code given there. This will allow you to get a better hang of writing the code and to test whether you truly understand the topics. Furthermore, writing code regularly, even if it’s code that you see in a video, is a very useful way to practice writing with fewer errors. As you will quickly see, a single missing semicolon or an extra space can make your whole program break – everyone makes plenty of such mistakes at first (and even when they’re experienced!). Regular practice of writing code is something that will allow you to get better at making fewer of such mistakes.

Next, for anyone to be truly successful in the field of web development, they need to be curious about it and to enjoy exploring it. The field is broad, developing rapidly and the ability to code provides so many opportunities, that there’s always new technologies, ideas and skills that you could be exploring. Because of this, we strongly encourage you to approach this course in the following way: when reading a resource, be aware of the questions that pop into your mind – write them down in a dedicated notepad (digital or not). Once you finish the resource, spend up to the same amount of time trying to answer those questions that you have written down (this will of course depend heavily on the exact resource). You will notice that some of these questions get answered in the resource itself, but some might not – in that case, search for more information yourself – whether it’s online searching, experimenting or discussing your ideas with other peer learners. This will allow you to build a personalized and unique set of knowledge! Finally, noting such questions down while learning will make it much easier to prepare for stand-ups at Turing College.

The suggested time next to many resources will assume this kind of learning - active practice and experimentation with the tools or knowledge learned and also additional time spent exploring topics related to the main ones that you find yourself to be curious about.

Sprint 1 - First steps into programming

In this sprint, you will learn to work with the Python programming language and the most common development tools. Just as importantly, besides technical skills, it will teach you the learning habits that will help you throughout the whole course and which will eventually make it much easier for you to land your first web development job. By the end of it, you will be ready for your first 1–1 project review with an expert!

Key learning topics & resources for this part

Visual Studio Code for CS50 (1 hour)
This is the tool that we suggest using for most of your coding when you start. You can use other tools as well if you are comfortable with it, but it can lead to potential difficulties with using the CS50 system in the problem sets.

You will need to create a GitHub account if you do not have one already. This same GitHub account will also be used for submitting your projects in the Turing College platform.

CS50P - Functions, Variables (3 hours)
We strongly suggest typing out the things shown in the video. If you find you already know these basics or have watched this video previously, you can either choose to watch the video at a higher speed or if you are extremely confident - skip it.


CS50P - problem set 0  (2 hours)
Some steps need to be done differently in order to work with the Turing College CS50 environment:
Step 1: skip this step
Step 2: submit this form instead: https://submit.cs50.io/invites/82f6b05c113d414691ec567ef7a9a679 (authenticate your GitHub account that you will be using for Turing College)
All other steps should be followed as they are written

Solve the 5 exercises, confirm them using check50 and submit them using submit50.

There isNote that Turing College staff will be able to see these submissions. While we will not be checking all of them, we might do so in case we see that there are some particular gaps of knowledge in order to discuss and help you with the relevant exercises.

Importance of fast typing and general computer use proficiency (1 hour)

As a developer, you will be typing a lot and you want to make sure that you can do that efficiently! Learning to type fast, besides being extremely useful in multiple ways, can also be used as a break between the more mentally demanding parts of the course. It can be a fun way to vary your learning routine and to do something that will lead to really easily measurable progress.

Our recommendation would be to practice for ~20 minutes daily until you can reach at least 60 words per minute (wpm) at https://www.livechat.com/typing-speed-test/#/ consistently. For practicing, there are multiple resources online, such as https://www.typingstudy.com/ , https://monkeytype.com/ , https://www.typing.com/student and others – you can choose the one that you prefer and which suits your level best.


Why is this important? First of all, efficiency – you want to practice to do things quickly, as it can directly affect how much value you can create as a developer in a set amount of time. This does not apply to all the situations though – when doing complex coding, you are likely to spend 90% or more of the time thinking and only the rest actually typing. But there is also going to be a lot of times when you are doing routine tasks that you know exactly how to do and you simply need to do it fast.

Furthermore, there's another important reason to practice and focus on this - other programmers are likely to guess your skill level (whether consciously or unconsciously) based on how you use the computer. This is relevant both during interviews in case you are asked to do some live coding and also when you start working. E.g., if someone sees you type fast, not look at the keyboard, use shortcuts efficiently and quickly, they will almost always automatically judge you as more competent. On the other hand, if you demonstrate inefficient and inexperienced use, e.g. typing very slowly looking at your keyboard, only then looking at the monitor to check if you’ve made any mistakes, using your mouse to copy and paste things instead of using ctrl-c + ctrl+v (or cmd-c + cmd-v), you will likely create an image of someone who will not be a proficient developer.


A side note on things that can improve or damage your image as a developer - a non-obvious and sometimes unconscious thing that makes you appear proficient or not is your use of English. English is almost inevitable when you are a developer, because all the documentation for the tools you will use are going to be in this language. Turing College therefore uses English  whenever possible. You are expected to talk in English during standups, during code reviews, on Discord – even if everyone speaks the same native language other than English. Such regular English practice throughout the whole course will make you much more comfortable and better with the language.


Revision of core Turing College concepts  (30 minutes)

In case you haven’t before, be sure to read the following documents about the core aspects of Turing College. The first quizzes may even contain questions that will test your understanding of these topics.
Stand-ups
Deadlines
Communication channels



Direction for further research (1+ hours)
Some parts will have sections called "Direction for further research" which will provide prompts for further, optional and more personalized learning experiences based on a learner’s individual interests and goals. A learner can choose to explore the directions suggested by us, or they can look for some other topics on their own. Either way, we advise every learner to look for additional topics that they are curious about often and dedicate at least an hour or two in each Part for these explorations. This way, you will have the opportunity to develop your own unique strengths and also have time for being curious.

The exact time you spend on these questions depends on your availability – try to plan your schedule in such a way that you can meet the deadlines set in the Turing Platform. If a direction is time consuming, you can choose to research it during multiple parts as well (for example, the suggestion to try installing Linux is likely to require quite a bit of time, especially because once you install it, you will likely want to play around with it!).

When exploring these in these directions, try to be mindful whether it is something that is likely to be crucial for your learning or if it is just something that is "nice to know". It can be very hard to determine the importance of such topics on your own quickly sometimes – open sessions and stand-ups are therefore great opportunities to discuss these things with others! However, identification of the importance of topics is crucial when aiming to become a self-directed learner.

Easy: In the functions example, would the code work if the main() function was defined after the hello() function? Why?
Try to run a Python program on your machine without the online VSCode IDE.
What is the difference between CLI, console, terminal and shell? Or are these synonyms? Is the distinction, if there is any, actually relevant in most conversations and for practical use?
Advanced: Installing Linux if you haven't done that before. Recommended if you are using Windows and have some experience with programming and find this sprint to be very easy for you. We recommend Ubuntu for starting: https://ubuntu.com/desktop. With a Mac, the installation is much more complicated and you don't get as much benefit, since the command line in MacOS is very similar to Linux. A slightly easier version of this (but still recommended for advanced learners only) is trying out the Windows Subsystem for Linux (WSL) – an easier and quicker way to get access to a Linux system if you are using Windows (which is actually extremely powerful and can be used by experienced developers).

Your first quiz
Once you have gone through the material, it’s time for the first quiz!

Note that while some questions might have a direct answer to them in the resources you’ve read, some will not (especially in later sprints). Use these questions as an indication of whether you are raising the right questions yourself and whether you are exploring them deeply enough.

If you don’t answer some of the questions correctly, do not worry – these quizzes are for self reflection only and will not impact your progress at Turing College in any way. Simply use them as a potential indicator for the topics that you can study further if you want to. If you disagree with an answer, first discuss it with your peers, JTLs or STLs and if you still think there’s an error in the answer, we would greatly appreciate it if you could message us via the support chat and let us know.

Good luck!



Part 2: Conditionals

Part description
Congratulations on completing the first part! You can already be proud of the fact that you have started writing your own code in Python. Next, we will continue learning more about how some of the core concepts in programming work – conditional statements.

We will also delve a bit deeper into debugging your code. Almost certainly, by now you will have written some code that will have resulted in some errors. It is very important to try to understand those errors and have the tools to find them.


Key learning topics & resources for this part


CS50P - Conditionals (2 hours)
Remember to write the code you see yourself. Also, try to do some experimenting. For example, when watching the part about if and elif, you might ask yourself a question – can you have if statements within if statements? Try it out!


Debugging (2 hours)
Debugging Python in VSCode - 01 - Intro to Debugging in VSCode
Debugging Python in VSCode - 02 - Step Over Line of Code
Debugging Python in VSCode - 03 - Step Into and Step Out

Besides giving some great tips on how to debug your code, we would also like to use this video as an illustration and exercise for another thing that you are likely to encounter very often both when learning and when working as a web developer. The instructions and guides that you see might often have some small (or sometimes not small at all!) discrepancies compared to what you see on your own computer. You will inevitably need to learn how to deal with such situations, as frustrating as they might be. With time you will get an intuitive understanding regarding what parts you can freely tinker with in order to get the results you need.

The words "tinkering" or "experimenting" are particularly fitting here – a developer will often simply try different things that might potentially work without being fully sure of what will happen, look at what the results are and move towards a solution this way. And yes, in some cases, you might break things this way – but it is expected and you should not be too afraid of it (although evaluating the risk of what you can break is another useful skill that you will get good at)! If you do break something – it just means that you will need to find a way to fix it – a new challenge, but something that will likely lead to additional useful insights and learning as well! An important thing separating a novice developer from a senior one is often not the amount of general knowledge about how "things should be done right" - it is actually the experience and the capability to identify why things go wrong and how to solve that!

In this particular video you might notice that once the button with play and bug icon is pressed on the left, there are immediately tabs called "Variables", "Watch", "Call stack". However, if you click the same button in your online version of VS Code, something else might appear and the tabs will not be there (although such things can change quickly - it could be possible that when you are reading this, everything will work exactly as in the video! Do let Turing College know if that’s the case :) ). Your exercise in this case is to tinker with VS Code to try and find out how to reach the same kind of tab on the left as you see in the video and how to then perform the debugging just as in the video (you should be able to write and understand a program identical to what is being shown).

Try to do this as soon as you reach this part of the video. If you get truly stuck (this can actually be a very hard exercise, especially depending on how your environment will work) – try to use the open sessions, stand-ups and Discord to get help and move on to the CS50P Problem set in the meantime.

Some hints:
Try to notice all the errors that are being shown;
Google the errors if you are not sure what they mean (if the error is large, you might want to google only the part which you think is the most relevant);
Depending on the error that you get, you might even need to use some of the knowledge you gained in the previous part regarding command line, specifically determining the location of files.
.json is a common file format used for controlling the settings of a program. You might want to try to understand if the debugging part is controlled by a .json file and if some changes could be needed there. The errors might give a hint regarding what needs to be changed.
You might find a different way to solve the issue without using the hints above.


CS50P - Problem set 1 (3 hours)
Solve and submit all 5 problems.


Core TC concepts (1 hour)
Junior Team Leads
Senior Team Leads
Self paced Learning
Open sessions
TC Vocabulary






Reminder
Remember to dedicate time to regularly practicing fast (touch) typing :)


Part 3: Loops

Part description
In this part, you will learn about loops, arrays and other common data structures used in Python. Once you know these, you will have quite a lot of capabilities already to write rather powerful programs!

With more complicated programming comes more complicated problems as well though! We will continue learning about how to identify and solve the issues that arise. We will look into some of the most common (and also modern) ways how developers find help online.


Key learning topics & resources for this part

CS50P - Loops (3 hours)

Getting help online (1 hour)

Struggles, unknown errors and issues when coding are inevitable – no matter what your experience level is. Besides debugging, developers always use various online tools to find the answers to their questions. We list some of the most common ones here and give some tips on how to use them effectively.

Stackoverflow
This is the most common website for asking programming related questions. Whenever you search for a question online, it is likely that you will find a Stack Overflow page on it. Unless your question is extremely specific and rare (this is extremely unlikely when you are just starting to learn the basics of coding), there is going to be a question about it already – so you do not actually need to be asking questions yourself most of the time – you just need to find a thread about the same question that someone else has asked and answered already.

You should be mindful about several things when checking the answers, however – not only whether the answer is the top rated one. It is always a good idea to check the comments below the answers – quite often, there might be some nuances that are worth noting. Furthermore, check the date of the answer – sometimes an older answer will be the most upvoted one, even though there could be a more recent, better solution with with newer versions of the programming language/tool in question.

You should not be afraid to copy the code you find on Stack Overflow – however, you should always try to understand how it works, if possible.

ChatGPT, Bing and other AI assistants

Chat bots like ChatGPT or Bing Chat are surprisingly good at helping with programming questions. Not only can they explain a concept that you ask about but they can also write code that you ask for or even debug your own code. These capabilities can make learning and work significantly easier and faster – we definitely recommend trying to incorporate these into your toolset. To do it effectively though, you need to be very aware of the strengths and weaknesses.

The biggest issue with AI Chat tools right now is that they still give wrong answers with extreme confidence quite often. Because of this, it is crucial that whenever you do get help from these tools, you double-check the correctness of the answers. For example – if you get a piece of code – test it with various inputs to see if it really does what it says it does. If it explains how a particular function works – try it out to confirm it yourself. If it gives you a conceptual answer – try to find a reliable source of information online to confirm it (e.g. a documentation or a reliable, up-to-date video explaining the concept).

Besides chat bots, there are also tools meant specifically for AI-assisted coding, such as Google co-pilot. We will cover these later, since for now, while learning, it is better to write as much code on your own as possible – that way once you do use more advanced AI tools, you will be able to do it much more efficiently.

Note: at the time of writing, Bing Chat is only available if you opt-in for early access and get an invite. We strongly recommend you try to get this invite, as the search function it provides can be extremely useful – it can give links to the sources of information it uses, which makes it much easier to check for accuracy (which is still needed, as it can give answers that are wrong or even contrary to what is said in the linked pages!).

Documentations
While not always the most user-friendly source of information, especially when you are just starting out as a developer, documentations are an indispensable part of how to get reliable information about how a programming language, a library or a piece of software works. It is a good idea to start practicing reading documentations early. Our recommendation is that every once in a while, when you learn a new function or when you’re searching for one, you should try to read the documentation for it. The example with print() function in the previous CS50P video is a good one – you can do the same for all the functions in Python if you wanted to.

A thing to keep in mind is that while documentations for popular programming languages like Python are extremely well written and are almost always up-to-date, once you get to less widely used tools, their documentations can be much less accurate. As an extreme example, the new and quickly developing web3 space has languages where the documentation can be inaccurate almost as often as it is accurate!

Youtube videos
If you have more time and want a more easy-to-follow way to learn something, you can always search for a specific concept explanation on Youtube. Once again – be sure to check whether the video is recent enough to make sure that you are not viewing something that is only applicable for older versions. For example, while Python 3 is the default version of the language, Python 2 was still used very widely just a couple of years ago – because of this, you might still find videos that will appear to use a slightly different syntax (one of the most common ways how you can notice an old version of Python is using the print function without any brackets).


Try to regularly and consciously switch between using all of these tools. During learning, it might be tempting to use only one tool if it works for you, but it is certainly better if you get comfortable with all of them – that way a much wider range of information will become available to you.

Debugging continued (1 hour)
Debugging Python in VSCode - 04 - Working Through a Problem
In this example, you will notice something you haven’t seen before – usage of enumerate() on a list. While the problem in the video can be solved already by the techniques you know from CS50P videos, use this as an opportunity to try to learn about a new concept on your own. It’s a perfect opportunity to try using the online help tools you just learned about.

CS50P - Problem set 2 (3 hours)
Note that at this point, the questions might start to become a bit more challenging – it might not always be enough to simply remember everything shown in the accompanying video. What you should do, however, is start to try to explore the functionality of Python more deeply. You should start making guesses about what features there might be in the language, searching for them online and testing them out if you find them. As an example, when you start working on the first problem, you might first think to check whether a character is capitalized by comparing it to every single uppercase character that you write. However, as a developer, whenever you find yourself writing something tedious which repeats a lot, you should start asking yourself – maybe there’s a better way to do this? For example, maybe there is an existing function that you could use to test if a character is uppercase or not? With a question like this, you could then use the knowledge learned about getting help online to quickly test your assumptions.

Direction for further research (1+ hours):
Are the limits to what values a dictionary can contain? What about keys? Can a dictionary contain dictionaries?
What does "Stack Overflow" actually mean?
Try to find problems or questions that ChatGPT will answer incorrectly.
Try to glance over the documentation of in-built functions at https://docs.python.org/3/library/functions.html. Maybe you can find some functions that are relatively easy to understand and useful?
What are the main differences between Python 2 and Python 3?


Reminder
Spend some time daily to practice touch typing if you cannot reach 60 wpm consistently yet. Also, if you notice that you are clicking some buttons often – check if there might be a keybind for it. Developers sometimes like to challenge themselves to use the mouse as little as possible (or not at all) – while this can be more of a vanity thing most of the time, it is still interesting to try sometimes and a useful way to make your workflow more efficient.
Part 4: Hands-on - tic-tac-toe

Part description
This will be the first "Hands-on" Part. These parts allow you to attempt a task on your own first and then compare it with the provided solution. We strongly advise you to attempt the task before completing this part to see the answer.

You should expect this (and the graded) task to be significantly more challenging than what you encountered in the CS50P problem sets so far. There are a couple of reasons for this. First, CS50P does not provide larger scale tasks, which require a different, yet vital skill – namely structuring the logic of a more complex program, even if the constituent parts are relatively simple. While it may be very challenging at first, practice will make solving subsequent complex problems much easier.

The second, very important reason for increased complexity is to push our learners to study together and utilize the community aspect of Turing College. **A significant part of learners are not expected to be able to solve this task on their own at this point of their learning** – especially if they are new to programming. However, we put a lot of effort into forming learner batches that work well together – complete with learners that can help others and those who would benefit from this help. By asking for help, you are by no means showing weakness or a lack of skill. Instead, asking for help, while hard for most people at first, is one of the core learning steps that you will need to take to become successful at coding. Not only will it make your progress much faster, but it will also make it more fun as you start to interact more with other people that are on the same journey as you. It will also teach you a crucial piece of mindset that a junior developer is expected to have – a new developer is expected to struggle with things and they are expected to be able to ask for help once struggling on their own becomes inefficient.

The plan for approaching this problem can be as follows: for the first hour or two, try to solve the problem on your own. Feel free to use the tools that you have learned about - web search, ChatGPT, StackOverflow, documentations. The only thing to avoid is trying to get the complete solutions – e.g. asking ChatGPT for a full implementation or looking for one online would not teach you that much (especially because it might contain some errors). However, you can definitely ask ChatGPT for feedback on your code or for information regarding how Python works.

If after this initial hour or two you see that you are making little or no progress, you should turn to the community for help. Ask in the appropriate module channel (#module_1) if anyone would be interested in working together or helping you with module 1’s hands-on challenge. You can also join open sessions by JTLs to ask for help as well. In all these cases, it is good to try to have an idea on how you would describe what you are struggling with. E.g. don’t just say "I don’t know where to start" – instead, try to explain what you’ve attempted so far, why it didn’t work and whether you have any potential ideas of what you could try next. Maybe there’s some specific things that are preventing you from trying some of these ideas? E.g. maybe you can’t get a specific function to work or maybe you are getting some errors that you can’t figure out? Or maybe you can’t figure out how to add, even in pseudo-code, some specific task requirements?

If you cannot complete the task within 10 hours of work even with the help of others, you should complete the part by doing its quiz and view the suggested solution. It will give you a lot of guidance and still allow you to challenge yourself. In such cases it is completely OK to spend at least 5 more hours working on understanding the suggested solution.

## Academic Honesty

When working with others, a common question is what may count as fair group-work and what may count as cheating. Generally, we try to follow the guidelines set here. For non-graded tasks, such as problem sets or hands-on tasks, the rules are more relaxed - you are free (and even encouraged) to work together with learners who are also currently working on the task.

For graded tasks (i.e. projects requiring corrections), learners should never share complete solutions or parts of a working solution to learners who have not yet successfully passed the project (i.e. completed the corrections and received a passing grade). There are therefore two types of interactions when it comes to graded tasks:
Learners who have completed the task can discuss it freely among themselves or with JTLs
A learner who has not completed the task yet can get help and feedback **on their own code**. Anyone can help the learner by commenting on their code, asking useful questions and giving tips, but nobody can share pieces of code that could be a sizable part of the final solution (*‘Sizeable’ is mentioned in this case because it can still be fine to give small, generic pieces of code, such as an example how to use the random() function – use common sense :) *)

Task Description
For this task, you are asked to create a console based tic-tac-toe game in which the computer will play against you. The good news is that you will be able to win sometimes, as the computer will play randomly! You are provided with these requirements for the program:
The user always makes the first move
The user should be asked to input their move until the game ends. The format for input should be "x, y" where x is the horizontal axis and y is the vertical axis. Upper left spot is 0, 0, lower right is 2, 2. (While it can seem weird at first, developers love indexing things from 0). You can assume that the user will always enter their input in the form "<digit>,<digit>" (i.e., no negative numbers, letters, symbols and multiple-digit numbers)
After the user enters a move, the computer should make their move, if possible.
Every time the computer makes its move, the state of the board should be printed out. The design does not need to be perfect – the important thing is that the state of the board should be clear.
If either the player or the computer wins, the state of the board should be printed out and the winner announced. The program should exit at that point.

Additional challenge: if you are more proficient at coding and find the task relatively easy (e.g. it took you less than four hours to complete), try to make the computer play optimally instead of randomly. Be sure to still read the suggested solution document, though!

Hints
When starting, try to write out the logic of the program with functions that are not implemented yet. This can help you split the problem into smaller pieces more easily. Then start implementing the functions one by one, testing them. Expect bugs to happen! Remember that you can use the debugging tools to figure out what the issues are. Also, if you see that you might need some additional functions that you have not yet seen (e.g. for making random choices for the computer), try to use the online tools that you have learned about.

Viewing the suggested solution
Once you finish working on the task and are happy with the result, complete this part just as you would a normal one. Then, after completing the quiz, navigate back to this part and you will see a button "suggested solution" at the top. Click it and you will see a detailed explanation of how a programmer might approach a program like this. Even if you have completed the exercise on your own fully, it can be a very useful exercise to read through code written by others. The provided solution is deliberately written to show how the process of coding may look like - together with bugs and debugging them.
Part 5: Sprint practical project - a chess question


Project description

Most likely, if you compare developers to the general population, you will find that developers are more likely to play (or at least know how to play) chess. Ignoring the causation/correlation question of this, we will assume that knowing the rules of chess will at least not hurt your chances of becoming an amazing developer in the long run.

The first practical graded task will require you to implement a Python program which will answer a simple question – given a board state that the user enters, with 1 white figure and up to 16 black figures, which black figures can the white figure take?

The exact criteria you are given to implement are as follows:
- The program should first ask the user to input a chess piece and where it is on the board. This will be the white piece. The user should be informed that they can choose between two pieces of your choice (e.g. pawn and rook). The choice should be made by writing the piece and the coordinates in a predefined format <piece location> in the console, e.g.: knight a5
- Once the user successfully adds the white piece, the user is asked to enter the black pieces, one by one, in the same format as the white piece. They need to add at least 1 black piece or 16 at most. Once at least one black piece has been added, the user can write "done" instead of the coordinates to add no more pieces.
- You can assume that the user will input either "done" or the correct format for adding a piece ("piece coordinates"). You can also assume that coordinates will always be entered as <letter><digit> where letters are a-h and digits are 1-8, e.g. a1, d4, h8. You should not assume anything else about the inputs, however (*hint*: there are still at least a couple of ways for the user to make invalid input, e.g. trying to write "done" too early)
- After adding each piece, there should be either a confirmation that it was added successfully, or an error message explaining what the issue is.
- After the white and the black pieces are added, the program should print out the black pieces, if any, that the white piece can take.

Important note on project requirements:
In real life work, the majority of development projects will be described in such a way that there might be some parts that are not defined explicitly. This can be due to lack of time, lack of experience or simply because it is extremely hard to think about everything before you are actually able to see the working program. The missing requirements can be some functionalities or edge/corner cases (e.g. strange inputs by the user) that were not originally thought of. In these cases, it is then up to the developer to either:
Ask follow-up questions to ensure that what they’re building is truly according to the demands and specifications
Make educated guesses/assumptions about how the program should work.

In this project, whenever you are unclear about a requirement or how the program should work, make an educated guess. Write all of these down as a list of comments at the end of the Python file that you submit.

Finally, if you don’t know chess, keep in mind that to solve problems at work as a developer, you will sometimes need to learn more about the industry in which you are working. E.g. if you start working as a developer for a logistics company, you will benefit greatly from gaining at least a basic understanding of how logistics work.


Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)

- How do you define a function in Python? How can you easily test whether something is a function in Python? How do you define parameters of a function?
- What is the difference between a list and a dictionary?
- What is pseudocode?
- Can you show how you debug the program that you have written? Could you make a small change in the code and explain what it will do?

Reviewer role
Different projects may require you to structure your presentation in different ways based on the imagined role of the reviewer. The goal is to practise interacting with different stakeholders that a developer will likely encounter in their careers.

In this project, imagine that you are introducing your project to a developer team lead in your company. They have technical expertise and will fully understand the work that you have done. You want to demonstrate both that the program works and to explain what the thought process was in the code and writing it. Keep in mind that even when you are presenting to technical experts, you should usually start by asking them if they’d like you to run the code and walk them through the program. Almost always, this is much better than going straight into code.


Project evaluation criteria
- The program correctly adds the white piece. Weight: 1
- The program correctly adds the black pieces. Weight: 1
- The program correctly says which black pieces the white piece can take. Weight: 1
- Code quality (at this point, you are expected to write code that is relatively tidy and easy to follow. You can refer to the hands-on suggested solution for the level that may be expected from you). Weight: 1
- General understanding of the sprint topics (the reviewer may ask you about topics covered in the sprint and the code that you have written). Weight: 2

Other info:

Read an in-depth guide about corrections here: https://turingcollege.atlassian.net/wiki/spaces/DLG/pages/537395951/Peer+expert+reviews+corrections

Submission
To submit the project and allow the reviewer to view your work beforehand, go to your GitHub repository by clicking on the GitHub icon above. Next, select "Add File"->"Upload Files". Choose the files you worked on to upload them, then click the green "Commit changes" button.
Note: in future projects, you will be using a different repository each time – you can access the correct one by clicking on the GitHub icon in the project page. Your reviewers only get access to the repository of the project that they will be reviewing.
Once you have completed all the steps of the project and uploaded your work, go to the Turing Platform and click the "Submit Project" button to complete it. The platform then allows you to see the times when reviewers are available to have a call with you and review the project. Simply book a time that suits you. If there are no times available, feel free to message us in the #wd_correction_scheduling channel on Discord — we will make sure that a reviewer adds a time for you as soon as possible.
Once your call with the reviewer is done, both you and the reviewer will need to enter your feedback in the Turing College platform. The review will be marked as done only when the feedback is entered by both users. You will be able to enter your review on this page after your reviewer has added theirs.

Estimate average time to complete: 20 hours


Sprint 2 - Intermediate Programming with Python

Sprint goals
Learn how to handle exceptions in Python
Learn to use libraries and packages
Learn to use external APIs
Learn the basics of unit testing

Part 1: Exceptions

Congratulations on completing your first sprint -  you have done an amazing job and now possess significant skills when it comes to the basics of programming! We are not stopping here, however, as there are still many additional concepts to learn.

In this sprint, we will learn about exceptions, libraries, external API’s and basics of unit testing. Similarly to functions, variables, conditionals and loops, these concepts are used extensively in nearly all of programming. While understanding exceptions and testing will make you capable of writing more robust code which is capable of elegantly dealing with potential issues, the use of libraries and APIs will make an incredibly wider array of features available to you. For now though, let’s start with exceptions…

Key learning topics & resources for this part
CS50P - Exceptions (2 hours)

A quick summary of exceptions (0.5 hours)
Besides a summary of the syntax shown in CS50P videos, you will see an additional `finally` statement and an example of how to raise your own exceptions.

CS50P - problem set 3 (3 hours)

Keybinds (1 hour)
During this sprint, try to find 5 keybinds or shortcuts in your IDE that are useful to you when coding. Try to use them regularly to make it a habit. During the correction at the end of this sprint, you will be asked to share the 5 keybinds/shortcuts with the reviewers (and since you will be performing reviews as well, someone else will share theirs with you too!). At least 3 of the keybinds should not be trivial, e.g. ctrl+c, ctrl+v, ctrl+f would not count, but ctrl (cmd) + left-click on a function to go to the definition of the function is perfect.

One way to find the available keybinds is by clicking the cogwheel icon in the bottom-left of the VS Code screen and clicking on keyboard shortcuts (there’s even a shortcut for accessing this list as well!). You will see a huge list of keybinds here though, so you might want to approach it a bit differently at first – maybe searching the web for "most useful keybinds for VS code" first.


Direction for further research (1+ hours):
How many different built-in errors does Python have? Where might you be able to check them?
The "outdated" problem mentions that computers usually format the date as "YYYY-MM-DD". Is that the format that computers usually store dates internally though?
What was the "Year 2000 problem"?





Part 2: Libraries and APIs

Part description

In this part, we will first go deeper into libraries - whether they are in-built ones or available to download. You will have already encountered these briefly in the hands-on exercise most likely – notably the random module. Understanding libraries and packages more deeply will expand the capabilities of your programs immensely! We will then continue to another concept that will open up even more capabilities to you - external APIs that you can interact with (with the help of libraries!). Finally, we will briefly look into popular ways to style your code nicely.
Key learning topics & resources for this part

CS50P - Libraries (3 hours)
It is very important that you learn how to install packages. If you are struggling to get `pip install <package>` to work, joining open sessions by JTLs can be a really good way to get personalized help regarding this.

You can test if everything works correctly by trying to install the `cowsay` package mentioned and trying to run it in your program.

CS50P - Style (1 hour)
Do not spend too much time on this just yet. We are currently working with Python to learn the concepts universal to most programming languages, not just Python. So we are not that concerned with getting great at writing Python code that follows exact standards such as PEP8. However, it is still good to be aware of these guidelines in order to better reason about and build a personal sense of what is well-styled code.

For the sake of practice, however, we advise you to go through some of your past code and try to format it according to some rules from PEP8 of your choice. Try to notice which changes seem the most meaningful and useful to you. Afterwards, use the black formatter to format it automatically and see what other changes it makes. You are also advised to use the black formatter in all the code submissions that you make in order to make it easier to read for the reviewers.

CS50P - problem set 4 (3 hours)



Direction for further research (1+ hours):
What are some other common modules in Python that you might find useful? Choose 1 that you have not seen in the CS50P videos yet. They can be either in-built modules or not (i.e. modules you will need to install before being able to import them).
Why are all modules not available immediately? E.g. why do you need to import the random module instead of it being available by default?
How would you create a program that would use named arguments when it is entered? E.g. `python my_program.py --name Alice`
How does pip work in more detail? E.g. where does the package get installed?


Part 3: Unit Tests

Part description

In this Part, we will learn about unit tests. By incorporating unit tests in your code, you can make it much easier to notice if some changes that you have made created some new issues. This can make your code much more reliable and the development process easier – instead of testing various scenarios manually one at a time each time you make some changes, you can simply use a single command to run all the tests that you have written previously.

Key learning topics & resources for this part

CS50P - Unit Tests (2 hours)
Note: for any exercises in the future that you are asked to write unit tests, you can use pytest.

CS50P - Problem set 5 (3 hours)

HackerRank exercises (2 hours)


Solve Me First (C4, 0.5)
Birthday Cake Candles (C4, 0.5)
Staircase (C4, 0.5)
Mini-Max Sum (C4, 0.5)
Plus Minus (C4, 0.5)


For these links, make sure that you have created an account at HackerRank and logged in. You can register for the platform here.
Throughout your studies, you will encounter similar programming exercise platforms quite often. The goal is to help you get into the habit of regularly doing small programming challenges like these, long after the initial CS50P problem sets. Just as the CS50P problem sets, they are different from the larger-scale practical projects that you encounter at the end of the sprints. Such small exercises usually either have some very specific concepts that they are meant to teach or are meant to allow you to revise what you already know and get more confident at it.
In some cases, especially in later exercises, you may need to do some research to understand the answer. It would be wrong to approach these challenges as if they are tests to evaluate your existing knowledge — expect to require some research. Not only is web search OK here (to explore concepts that could help you solve the problem, not searching for the exact solutions, of course), but it is actually encouraged if you don't figure out the answer quickly on your own. Just as with the larger projects, this approach will allow you to get better at effectively finding out new concepts in order to solve a problem.
Last but not least, a reason for doing these exercises is because they can be quite fun! Some developers really enjoy the puzzle aspect of these challenges. If you find yourself doing the same, feel free to look for more similar platforms.


**Notes & tips for using HackerRank:**
- In the solution window, choose Python 3 as the language.
- Using print statements and running the code regularly is a very good way to start and then to check your progress.
- Once you solve a problem, it's extremely useful to go through a couple of other solutions by other users and problem creators ("Leaderboard", "Discussions" and "Editorial" tabs). Try understanding at least one other way to solve the problem – this will make it easier and quicker to read code written by others and will also introduce you to new concepts. You will also start gaining an understanding of which solutions are good and which are not, even if all of them 'work'.


Direction for further research:
What is Test Driven Development?


Part 4: Hands-on - Your Own AI Chatbot

Part description

The goal of this hands-on exercise will be different from that of the first one. Instead of focusing on more complex logic, you will be figuring out how to implement a slightly more complex library. You will likely be surprised at how powerful the programs you write can already be, once you start using external packages!


Task description

Are you annoyed that ChatGPT works slowly sometimes? Or that it is sometimes non-reachable completely? It turns out, you already know enough concepts to build a program that interacts with OpenAI’s Chat API and to avoid all of those issues! Your task will be to create a program that will allow you to chat with ChatGPT via your terminal using OpenAI’s Chat Completion API.

The exact task requirements are as follows:

- Your program should accept two arguments when it is run: an API key and a name for the ChatBot. E.g. you should run it using:
`python gptbot <API_key> Bobby`
For a slight challenge, you can also use a system variable to securely pass in the API key, even though you have not learned about these yet.
You should get into the habit of never adding sensitive information directly into your main code files. It is surprising how often developers accidentally cause major security breaches by simply having sensitive information, like passwords or API keys in the files that they upload publicly, e.g. into Git repositories.
- The program, when started, should prompt the user for the first message.
- When user presses Enter, the program should get a response from GPT and print out the response message, starting it with `AI: `
- The user should then be able to continue the conversation (instead of starting it all over again with each input). This means you will be sending an ever longer message history to the API.
- The ChatBot should identify itself with the name you provided
- The program should end when you press ctrl+d (cmd+d on Mac) by printing out "Bye!"  and the total amount of tokens used in the conversation.
- The program should also end if the conversation becomes too long for the API.
- Your program should use the `openai` package and the ChatCompletion API. The engine to use is "gpt-3.5-turbo" or a more recent one if it is available.
- Your program should use at least one try/except statement
- Your program should have at least three unit tests that can be run using `pytest test`




Note: OpenAI provides free credits when you first start using the API. The free credits should be plenty for this exercise. If, on the other hand, you have used the credits before, you can try to simply create a new account. If OpenAI does not provide you with any free credits, please contact Turing College support via the platform chat.

**Hint:**

*(If you feel confident, try to solve the task without looking at the following)*

You will need to accomplish the following steps:
- Find the documentation for the OpenAI’s Chat Completion API and most likely some examples for sending simple API requests with Python
- Make sure you have an OpenAI account
- Get an API key and an Organization ID for a personal account
- Make your program accept the API key as a command line argument
- (optional) make the API key accessible via a system variable
- Install the required library via the terminal
- Test that you can send the most basic request and receive a response (note: even though you have learned to use the requests module, it is not always required to use it to make requests!)
- Enable continuation of the conversation
- Make the AI respond to the name that is passed as an argument.
- Keep a count how many tokens have been
- Write a couple of unit tests, ensuring that they are simple. If it seems it’s impossible to do so – maybe you need to split your functions a bit, so that you have more simple ones that you can test.
- Handle exiting of the program
- Double check that you have used at least one try/except statement


Bonus challenge
Create a program that makes chatGPT talk to itself. It should have two different personalities, one called Alice, one called Bob. Both of them should have a different temperature setting.

The user should click "enter" without any input if they would like the next conversation step to happen.

The user should also be able to type "topic: <description of a topic>". This should cause the AI in its next message to try to switch the topic to what the user has described. It is possible that this will not work fully reliably, but if you are curious about GPT, you can try to experiment how to make it happen more consistently.

If the user enters anything other than "topic: <description>" format, they should be informed that this is invalid input and asked to either enter it correctly or not enter any input at all.

Approach to solving the task
You are once again advised to take a similar approach as in the previous hands-on exercise:
- 1-2 hours of attempting to solve the task on your own
- If during the first 1-2 hours you see you are making no progress and that the task seems much too hard for you – we recommend 10 more hours working on the problem with help from peers and JTLs. Out of these 10 hours, you are expected to spend about half of them working with someone else – whether it is peer study buddies, peers who have completed the exercise and want to help you or JTLs in open sessions.
- If you still can’t solve it, check the suggested solution and spend as much time as needed (also based on what you have available until the next deadline) to understand it.


Part 5: Sprint Practical Project - APIs to Email

Welcome to your second practical project graded task!

This project will have a couple of differences compared to the first one. Just as in the hands-on exercise, the challenge in this task is going to be figuring out how to use specific libraries and APIs instead of writing complex logic. Furthermore, instead of a single STL correction, you will need to receive 2 peer corrections to pass this sprint. It also means that you will be able to start performing corrections to other learners yourself!

Project description

In this practical exercise, you will develop a Python program that will be able to fetch information from two different APIs and send the retrieved information as an email message.

The requirements you are given to implement are as follows:
- The program should be run with two command line arguments - an email address and an API to use (one out of two that you have implemented)
- Your program should first check if the format of the command line arguments is valid
- The email provided should be checked. It can be as complex as you choose to be – the most simple implementation would simply check whether an "@" and a "." exist.
- The program should check whether the API argument passed is one of the two that you have implemented
- Your program should then call the API chosen. E.g. the current weather in your town/current moon phase in your town/a currency exchange rate of your choice, or anything else that you choose.
- The information received from an API should be formatted into a human-readable message and sent to the email which was provided in the command line argument. You should use a Gmail account for sending the email.
-  **You should only use Python’s in-built libraries to send the email via a Gmail account**, i.e. you should not install any additional tools or libraries. We also recommend creating a new Gmail account meant specifically for this exercise instead of using your personal one - that way you will avoid any potential security issues.
- Your program should use the try/except statements at least once.
- Your program should have at least 3 unit tests.
- At the end of the file, as a comment, add the 5 keybinds you researched in Part 1 of this sprint

The APIs chosen should be different from the ones shown in the CS50P videos. A possible place to explore free APIs is https://github.com/public-apis/public-apis

Just as before, you should list any assumptions that you make about the requirements if they are not explicitly stated here.

You should expect to find multiple suggestions on how to send an email using Python and Gmail – some of them might look extremely complex, others might no longer work. Some of Google’s own guides might be out of date while some websites might even make the suggestions deliberately complex in order to advertise their own tools! Try not to worry though and continue tinkering with various solutions – you are expected to need to try multiple ones until you reach a solution that works. This is what real developers would usually need to do as well! Finally, you may also be required to do some additional steps than simply writing code (remember how you needed to generate an API key for using the openAI’s challenge).

Reviewer role
Different projects may require you to structure your presentation in different ways based on the imagined role of the reviewer. The goal is to practice interacting with different stakeholders that a developer will likely encounter in their careers.

In this project, imagine that you are introducing your project to a colleague developer of similar seniority, asking for their feedback. They have technical expertise and will try to understand the work that you have done, although they might not always be fully objective – they will instead be doing their best to give you feedback and ideas on how to make potential improvements. Similarly to presentations to a senior developer, you want to demonstrate both that the program works and to explain what the thought process was in the code and writing it.


Project evaluation criteria
- The program is able to accept two command line arguments
- The program checks whether command line arguments are valid
- The program is able to call two different APIs
- The program is able to create a message based on the information retrieved from the APIs
- The program is able to send an email via a Gmail account
- At least three unit tests are written
- At least one try/except block is used
- Organization and style of the code. The code should be easy to read, with well-named functions, variables, and comments.
- General understanding of sprint topics
- 5 keybinds listed at the end of the submission file

During a task review, you may get asked questions that test your understanding of covered topics.

**Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)**


- What is an API?
- What are some possible ways to call an API using Python?
- Why do we need unit tests?
- What are some criteria for good unit tests?

Submission

To submit the project and allow the reviewer to view your work beforehand, go to your GitHub repository by clicking on the GitHub icon above. Next, select "Add File"->"Upload Files". Choose the files you worked on to upload them, then click the green "Commit changes" button.
Note: the repository for this project is different from the one you used in the last project! Make sure you are using the correct one by clicking on the GitHub icon in this project’s page.
Once you have completed all the steps of the project and uploaded your work, go to the Turing Platform and click the "Submit Project" button to complete it. The platform then allows you to see the times when reviewers are available to have a call with you and review the project. Simply book a time that suits you. If there are no times available, feel free to write a message in the #wd_correction_scheduling channel on Discord. For this project, other peer learners who have submitted or completed this project will need to add their availability.
When booking a peer correction, you might get an STL if there are no learners available. However, the same STL can never perform both corrections for the same learner for the same sprint. **You do not have to worry about who (i.e. which role) gets assigned for your reviews – the platform handles this automatically.**

Performing peer corrections

*Once you have submitted your solution, add your availability to the platform so that others can book a correction with you*. To do this, you should click on the "My Availability" button in the top left corner of the Turing platform. By performing corrections, you will receive correction points which you will need to receive further peer corrections yourself.
Once someone books a correction with you, you will get a notification in your email and via Discord. Remember to check the uploaded work of the other learner before the correction. This will allow you to prepare and give better feedback.
Not all sprints allow you to perform corrections as soon as you submit them (before successfully passing the corrections yourself). For further sprints, unless stated otherwise, you should assume that you will only be able to perform corrections once you pass them successfully yourself.
Peer corrections, first and foremost, are meant to be a learning experience for both you and the learner you are reviewing. Evaluation is the secondary goal and we do not expect learners to be highly objective in their scores. Use peer corrections as an opportunity to not practice reading the code of others and seeing different ways of solving the problems you have worked on, but also to practice your soft skills as well.

Read an in-depth guide about corrections here: https://turingcollege.atlassian.net/wiki/spaces/DLG/pages/537395951/Peer+expert+reviews+corrections

Estimate average time to complete: 15 hours
Sprint 3 - Intermediate Programming with Python II
Part 1: Working with Files

Welcome to the third Sprint! There are only a couple of more topics to go before you can confidently say that you know the full extent of programming basics with Python. This sprint will cover most of these topics.

First, you will learn about working with files. This will allow you to write much more powerful code, as it will be capable of storing and sharing information between multiple runs of the program. It will also be an indirect introduction to working with databases that are a core part of web development.

Part 2 will cover a topic that is by far the most wide-ranging so far - Object-Oriented Programming. It will allow you to take a completely different approach to thinking about the code you write. It is the most widely used programming paradigm right now that is present in almost all the most popular programming languages - Python, Javascript, Java, Python, C++, and many more. This sprint will serve as a short introduction to it – you will have the whole course to master it though.

Part 3 will focus on collaborative programming work. This time, instead of a hands-on exercise, you will first learn about the capabilities of Git and GitHub. Then you will work on a project together with your peers utilizing the pair-programming approach. This will also serve as an opportunity to start practicing Object-Oriented programming more deeply.

For the 4th and final part, you will work on a project that will require you to combine all that you have learned so far. You will build a learning tool that will adapt to you based on what you know!

Expect parts 3 and 4 to be reasonably more complex than previous parts – that is the reason for only having 4 parts instead of 5 in this sprint.

<br>

# Key learning topics & resources for this part

<br>

## [CS50P – File I/O](https://cs50.harvard.edu/python/2022/weeks/6/) (4 hours)


## [CS50P – Problem Set 6](https://cs50.harvard.edu/python/2022/psets/6/) (4 hours)

<br>

# Direction for further research (1+ hours):
- What are some other parameters that can be used with the `open()` function?
- Why is it possible to iterate over a variable to which an opened file is assigned? Is it a list?
- How would you change one line in a file without overwriting the whole file?
- Reminder – are you practicing touch-typing regularly? What is the highest wpm that you can reach right now?
Part 2: Object-Oriented Programming

<br>

This part will focus on a programming paradigm called Object-Oriented Programming. It is extremely widely used today and has a lot of benefits when it comes to writing larger, more complex programs. In essence, it will allow you to start thinking about programs in a more intuitive way, because it models real-world concepts and systems more naturally. By representing real-world entities as objects and their interactions as methods, programmers can design software that is easier to understand and modify. Moreover, OOP's emphasis on encapsulation ensures that each object keeps its state private and exposes only what is necessary to the outside world. This principle not only enhances code security but also simplifies debugging, as changes in one part of the system are less likely to create unintended consequences elsewhere.

Learning OOP is undoubtedly worth the investment, as it equips you with the skills necessary to tackle complex projects with ease. By mastering OOP concepts, you'll be able to create more efficient, scalable, and flexible software that can adapt to changing requirements. CS50 will help you explore the foundational principles of OOP first. The remaining two parts of this sprint will then give you opportunities to practice these concepts further in more large-scale projects.

<br>

# Key learning topics & resources for this part

<br>

## [CS50P - Object-Oriented Programming](https://cs50.harvard.edu/python/2022/weeks/8/) (4 hours)

If you research more into OOP, you may find a description of the four core concepts of OOP: Encapsulation, Inheritance, Polymorphism and Abstraction. What this implies is that there is quite a lot to OOP that is not yet covered in this CS50 lecture. This is fine, however, as for now, we want to get comfortable with a more simple use of OOP (which in itself is a lot if you’re just starting out!). In future sprints and modules, you will use OOP a lot more and even encounter other languages that use it – we will dig even deeper into OOP then.

For complex and large topics like OOP, you might find that it is a good strategy to explore it consistently over a longer period of time instead of trying to learn everything all at once. I.e. instead of going down the rabbit hole of OOP readings and videos right now, you might want to get the core understanding that would then allow you to continue learning new concepts as you encounter them later on.

<br>

##  [Tips For Object-Oriented Programming](https://www.youtube.com/watch?v=-ghD-XjjO2g) (0.5 hours)


<br>

##  [Composition vs Inheritance](https://www.youtube.com/watch?v=0mcP8ZpUR38) (1 hour)

Remember that if you see concepts that you are not familiar with, e.g. a "@dataclass" decorator or an "ABC" class, you should be able to use the tools you know to find out more about them. E.g. you could ask ChatGPT questions like these to get detailed explanation and examples that you could run yourself and try out:
- What does @dataclass do python
- What is the ABC class in Python?
- Would I not be able to instantiate the MyConcreteClass if the abstract method was not defined in the MyConcreteClass?
- Can you use @dataclass for an abstract class?
- If a class inherits ABC but does not have any abstract methods, would it still be impossible to instantiate it?

<br>

## [CS50P - Problem set 8](https://cs50.harvard.edu/python/2022/psets/8/) (5 hours)

<br>

# Direction for further research (1+ hours):
- What are the pros and cons of different programming paradigms? In which cases/industries are specific paradigms used more than others?
- Assume you want to programmatically get all the parameters of any object - how would you do that without creating a new method for it?
- Is it possible to extract the exact code of a method inside a class? E.g. could you write a program that takes a class, a name of the function and then prints out the code which was made to define that method? What if it’s an in-built class and method, such as `list` and `__init__` for `list`?

Part 3: Version Control & Pair Programming Exercise

<br>

This part will be different from the Hands-on exercises before. Instead of focusing on individual work and comparing it to a given solution, we will start getting more experience with working in teams of developers. As you will see, this will encompass multiple different skills.

The part will start with a video introducing Git and GitHub. While you have been using GitHub already for uploading your projects, chances are, you will be surprised by the full breadth of functionality that Git offers (and how complex it might get sometimes). Version Control is a crucial part of pretty much every software development team, so knowing how to use it will be extremely important in your career.

After learning about GitHub, you will work on a more challenging task utilizing pair programming. In essence, pair programming means two people collaboratively working on the same coding problem at the same time. You will have likely already experienced something very similar in your STL correction if you were asked to make any changes to your code while sharing your screen. Similarly, in open sessions, JTLs often try to guide the learners when they are solving problems while sharing their screen. Besides being used in workplaces sometimes, pair programming has multiple learning benefits too:
Improving your capabilities of writing code under stress. Even in relaxed environments, writing code with someone watching and commenting can be stressful!
Improving your ability to explain your thought process while solving a coding problem
Improving your ability to quickly read and understand other people’s code
Seeing multiple ways to solve the same problem

Notice that the first two points are especially important in technical job interviews.

Finally, during this task, you will get a bit more freedom than previously – you will need to clearly define not only the assumptions that you make, but also some of the requirements for the program. Usually, non-developer team members such as Product Owners will be defining the overall goals of a task, but developers will then "refine" the tasks further to be able to agree clearly within their teams how the development should proceed. Sometimes, this will be limited to technical decisions only, other times – this can even lead to insights about how the whole program should work from the user-perspective. In this task, you will get an opportunity to practice planning and sharing the technical details and the overall design of the program.

<br>

# Key learning topics & resources for this part

<br>

## [Git and GitHub for Beginners Tutorial](https://www.youtube.com/watch?v=tRZGeaHPoaw) (3 hours)
While watching this video, you might get the feeling that Git is such a powerful yet complex tool that it might need a separate short course to master fully. Do not be discouraged by that – the main goals for you right now should be as follows:
- To be able to confidently do the core actions of version control - creating a repository, staging changes, committing them, pushing them to a remote repository and pulling remote changes.
- To be comfortable with how branches work, how to create and switch between them.
- To be comfortable with performing very simple merges between branches.
- To get an initial understanding of what merge conflicts are, so that if you do encounter them, you could start to dig deeper and eventually solve them.
- Know what pull requests are
- To get a sense of what else is possible with Git so that if you need it, you could search for it and find the solution. E.g. you don’t need to remember how rebasing or amending works, but you should be aware that in case you do need to change the history of a repository, that there are ways how it can be done.

<br>

## [Git Basics Reference](https://git-scm.com/docs/giteveryday) (0.5 hours)
## [Git Basics Reference (alternative)](https://education.github.com/git-cheat-sheet-education.pdf
) (0.5 hours)
## [https://www.ndpsoftware.com/git-cheatsheet.html#loc=index](Interactive Diagram for Git Commands (0.5 hours)
   - Note: you can click on separate columns

<br>

## [Git Practice](https://gitexercises.fracz.com/exercise/master) (4 hours)
Complete exercises up until the exercise `commit-lost` (inclusive)

<br>

After you’ve watched the "Git and GitHub for Beginners Tutorial" video, you may want to have a handy reference guide for quickly looking up the most commonly used commands. We recommend just skimming through it now to have an idea of what it contains and then using it later once you need to quickly remind yourself of some commands.

In your upcoming projects, you are very strongly encouraged to start using version control regularly. E.g. stage, commit and push your changes often, write informative commit messages; If you want to try adding a feature to your code but are not sure if it will work or not, try creating a branch for it first and making the changes there, then merging the branch. A big benefit of this is not only that you will get more comfortable with git, but you might also avoid losing your files in case something unfortunate happens to your local files (e.g. the hard drive gets corrupted).

Finally, by pushing commits to GitHub (even if it’s into private repositories), you will populate your personal account with activity which is publicly visible and which is very commonly checked by recruiters. If you start committing now when working on projects and have regular activity, it will help you significantly in the job search process later on. On the flipside, non-active Github repositories is a rather common way that companies immediately filter out entry-level candidates.  Keep in mind that this is something that you will not be able to "catch up" with quickly in case you skip it now – the earlier you start creating a history of activity, the better.

<div><img src="https://i.imgur.com/66k1gcS.png"></div>

<br>

# Direction for further research (1+ hours):
- What happens if you try to switch branches while you have changed unstaged files?
- Can you recover deleted git branches?
- What are some other popular software, such as GitHub, for managing Git repositories?
- What are some other popular tools for version control besides Git?

# Peer programming exercise (10 hours)

## Task description

You are asked to implement a children’s card game called [War](https://en.wikipedia.org/wiki/War_(card_game)). The main technical requirement is that you use the Object-Oriented Programming paradigm that you have learned recently. Besides that, you are free to decide how exactly the program should work. E.g. you can choose if the user needs to make any inputs to make moves; you can choose what the output of the program should look like; you may even decide that you want to implement a variation of the game that’s described in the Wikipedia article. Your goal will be to write this program utilizing Git and remote [pair programming](https://en.wikipedia.org/wiki/Pair_programming).

**Step 1**: Create a public GitHub repository with a README file. Clone it to your local machine. Every learner should have their own individual repository that they have created.

**Step 2**: In the README file, write down the requirements for your program. You are free to choose the format of the requirements – try to think of what you, as a developer, would want to see in such a file if you were to receive it as your task. Stage, commit and push the changes to the online repository *before writing any code*.

**Step 3**: Either in Discord, in a stand-up or an open session, ask if anyone else has started (or finished) working on this project and if they would be available for at least a 1-hour pair programming session. Arrange a time for such a session. You can also immediately arrange multiple times – either with the same person or different people. In total, you would ideally have at least 3 pair programming sessions for this task. Out of those 3 sessions, at least 1 should be working on your project and 1 working on somebody else’s project (again, remember that each learner has their own repository and their own implementation of the game).

**Step 4:** Before the arranged pair programming session, if you will be working on your project in your repository, split the upcoming tasks that you think will need to be done in the pair programming session into small GitHub issues. The initial requirements that you have described in the README file may be very helpful here. For example, you may have written, as part of your requirements – "At the start of each game, a deck needs to be initialized in a random order. Once it’s initialized, it should be split evenly between two players". This could be converted into two separate GitHub issues with these exact goals.

**Step 5**: When the session starts, decide who will go first (you can use the `random` module :) ). You should both aim to spend about half of the time coding and half of the time observing. Note - during the whole session, you should be working on just one project (i.e. either your repository or your peer’s).

The person writing code should assign the GitHub issue that they will be working on, share their screen and start working on the task. Note that if the first person writing code is the one working on someone else’s project, they will need to first clone the repository to their local machine. After half the time of the session is up, the person who was writing the code should commit and push their code to the repository so that the other person could continue where they left off. If the GitHub issue was completed, the issue should be closed as well.

**Step 6:** The roles should be reversed now and the session continues. Remember to pull the newest changes from the remote repository before beginning to code on a new machine. At the end, once again, commit and push the changes.

Bonus challenge – during the peer review exercise, try to deliberately cause a merge conflict, then solve it.

**Step 7** Between the sessions, you are free to do some coding yourself. It is likely that the pair-programming session may have given you some new insights that you will want to try out. However, you should make sure that there’s still enough tasks to do during upcoming sessions if you haven’t yet done at least 3 of them. In case you finish too much of the tasks and there’s not enough for an upcoming session,  you can either update the requirements by adding more of them or aim to join other people’s projects for their pair programming sessions.

**Steps 8**: Repeat steps 4-7 until you have completed at least 3 pair programming sessions. Once again, note that you can either have people join in to work on your project, or you can join others to work on theirs.

**Step 9:** If there’s still some tasks remaining, complete the program.

**Note: due to potentially needing to wait for the pair-programming sessions, you can work on this project in parallel to the main project. In extreme cases, you may even continue and complete this part after you have passed this sprint’s corrections.**

Part 4: Interactive Learning Tool

<br>

You will design and implement an interactive learning tool that allows users to create, practice, and test their knowledge using multiple-choice and freeform text questions. The program will track user statistics and provide options to manage the questions. It will be a program that you might even want to use yourself for learning!

Similarly to the hands-on exercise of this sprint, you will be given a bit more freedom regarding the exact way how your program will work – the requirements will deliberately leave the finer details for you to decide. This will allow you to practice thinking about the design of programs, not just the technical implementation.

<br>

## The requirements you are given to implement are as follows:

When the program starts, user should be able to choose between the following modes:
- **Adding questions**.
- **Statistics viewing**.
- **Disable/enable questions**.
- **Practice mode**.
- **Test mode**.
- (Bonus) **Profile Select**

<br>

## Adding questions mode:
In this mode, users should be able to add two types of questions - quiz questions or free-form text questions. A quiz question requires the user to choose one of the given answer options. A free-form question requires the user to enter some text and compare it with the expected answer to determine whether it is correct (it can be as simple as directly comparing the string saved as the answer and the answer given by the user).

The questions should be saved in a file so that once the program is closed and opened again, the questions remain.

The user should not be able to enter practice or test modes until at least 5 questions have been added.

<br>

## Statistics viewing mode:
The program should print out all the questions currently in the system. As a minimum, each question should list: its unique ID number; whether the question is active or not; the question text; the number of times it was shown during practice or tests; the percentage of times it was answered correctly.

<br>

## Disable/Enable Questions mode:
Users should be able to write the ID of the question they want to disable or enable. The question information (question text, answer) should be shown and the user should be asked to confirm whether they want to disable/enable it. Disabled questions should not appear in practice and test modes. The enabled/disabled status should be stored in a file, just like the questions.

<br>

## Practice mode:
A mode in which questions are given non-stop so that the user can practice. However, the questions are chosen in such a way that the questions that are answered correctly become less likely to appear, while questions that are answered incorrectly become more likely to appear. *Hint: you may want to look into weighted random choices*. The probabilities should not be reset when the program restarts.

## Test mode:
A mode for testing your knowledge. Users should first select the number of questions for the test which is not larger than the total number of questions added. The questions get chosen fully randomly and each question can only appear once at most in the test. At the end of the questions, the user is shown the score. The list of scores should be saved in a separate results.txt file – the date and time should be added next to the score as well.

## (Bonus) Profile Select:
*This will not affect your final score, but you may attempt it if you feel the main challenge was easy enough. Completing this may increase your chances of becoming a JTL if you decide to apply to be one later*.
Make it so that users can select a profile. Each profile should have individual statistics of how many times a question was answered correctly and thus individual probabilities of getting those questions in the practice mode. In the test mode, saved scores should also say which profile achieved each of the scores there. The questions should be shared between all profiles, however.

**You are free to make any further improvements to the program that you think could make it even more useful for the user. E.g. you could implement a "full reset" option that deletes all the questions.**

<br>

## Technical requirements:
- Use Object-Oriented Programming
- Use Regular expressions in at least one function
- Use file input/output
- Write at least 3 unit tests
- Submit the generated output files (for storing questions, test scores, etc.) to the GitHub repository too (not only the code).


- **At the end of the file, add a link to the public GitHub repository that contains your work from Part 4 so far.** If you are ahead in your batch, we expect that you might not yet have it fully done – however, the initial repository should still be there. Hopefully you should also have at least one session of peer programming done by the time you finish this sprint.

<br>

## Reviewer role
First, present the program as if you were presenting it to a potential user. Explain the code as if you are explaining it to a technical team lead. Try to go rather quickly through parts that are easy and focus more on explaining the most complicated parts of the code.

<br>

## Project evaluation criteria
- User is able to add questions of "quiz" and "free-form text" types
- Program uses OOP reasonably well. E.g. classes are chosen reasonably, features like getter/setter decorators may be used.
- User is able to see statistics of the questions
- User is able to disable/enable questions
- Practice mode works correctly
- Test mode works correctly
- Code quality. How readable and tidy is the code?
- Usability of the program – is the program easy to use for the user?

During a task review, you may get asked questions that test your understanding of covered topics.

**Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)**

- What are the potential benefits of using Object Oriented Programming?
- What is a .csv file?
- How would you go about writing a more complex regular expression?
- What are the most common Git commands?
- When does a merge conflict happen in Git?

<br>

# Submission

This project will require 1 STL and 1 Peer review.

For the sake of practicing Git, you are advised to use the command line to submit the project to the Turing GitHub repository.

Note: the repository for this project is different from the one you used in the last project! Make sure you are using the correct one by clicking on the GitHub icon in this project’s page.
Read an in-depth guide about corrections here: https://turingcollege.atlassian.net/wiki/spaces/DLG/pages/537395951/Peer+expert+reviews+corrections

<br>

**Estimate average time to complete: 25 hours**


Sprint 4 - Fundamentals of Computer Science I
Part 1: Regular Expressions

<br>

Welcome to the final sprint of module 1! You have demonstrated immense progress so far and have enough skills to build complex programs already! Very soon, in module 2, we will turn our attention to other programming languages and see how the same programming concepts that you have learned here apply to other languages as well.

Before moving to module 2 and the basics of front-end development, this sprint will cover a couple of final things. First, there are 2 more topics left in the CS50 Python videos. Afterwards, we will go through our first topic relating to core principles of Computer Science – namely algorithm complexity evaluation and the very popular BigO notation. In this part, you will have an early opportunity to compare Python to another programming language briefly – C. Finally, you will complete your first capstone project – an exciting task which will allow you to creatively use everything that you have learned so far building your first unique portfolio item.

Similarly to the last sprint, parts 3-4 are expected to take a significantly longer time.

For now though, let’s focus on the first part in which you will learn to use regular expressions. It is a tool some developers love and others hate – but most agree that it is very useful and unavoidable in certain situations. Regular expressions have immense capabilities when working with and when you want to find specific patterns in that text. While there are quite a few tools for working with Regular expressions, it is still necessary to have some experience of working with them on your own. CS50P will give a great introduction to that and you will also get to see some websites for practicing regular expressions even further.

<br>

# Key learning topics & resources for this part

<br>

## [CS50P – Regular Expressions](https://cs50.harvard.edu/python/2022/weeks/7/) (3 hours)

Note: ChatGPT and other regex-centered online tools are quite good for writing and testing regular expressions. Therefore, many developers will rarely need to fully manually create or understand complex regular expressions themselves. However, it is still very useful and important to learn the core ideas of regular expressions and get some practice so that you are comfortable with them once you do encounter them or so that you could identify where they could be used. Furthermore, you might encounter regular expressions (although usually quite simple ones) in job interviews as well where you won’t be allowed to use external tools.

<br>

## [Interactive Tool for Testing Regular expressions](https://regex101.com/)
This is a very commonly used tool for testing the regular expressions that you write or encounter.

<br>

## [CS50P - Problem Set 7](https://cs50.harvard.edu/python/2022/psets/7/) (4 hours)

<br>

# Further Regex challenges (2 hours)

There are multiple ways you can continue to practice regular expressions. Here we list just a few. We do not suggest spending more than 2 hours on them just yet though. Instead, for now, just see how far you can get and try to do them as a fun challenge. If you cannot get very far – that’s quite fine! On the other hand, if you do find working with them interesting and if you have some extra time, you could get back to these challenges every week or two and try to get further each time. This way you will better remember what you have learned and even continue to get better with regular expressions. Even if you do not do such regular practice, however, you will still encounter regular expressions from time to time which should be enough to maintain the basic knowledge level needed.

<br>

## [Regex Crossword](https://regexcrossword.com/)

<br>

## [Hackerrank Regex challenges](https://www.hackerrank.com/domains/regex)


<br>


# Direction for further research (1+ hours):
- How would you escape the escape character itself – the backslash "\"?
- In regex, why can't you use [a-Z] instead of [a-zA-Z] when you want to include all alphabet letters (both lowercase and uppercase)?
- What are some of the most common use-cases for regular expressions in web development?
- What issues might you encounter if you write your code using the walrus operator? Are there any ways to solve it that allows you to still use this operator in your code?
- How will matched groups work if you have brackets inside of brackets in your regular expression?
Part 2: Final Concepts of Python

<br>

In this part, we will finish the final topics of the CS50 Python course. The great thing about learning a language in more-depth like this is that it will make you familiar and comfortable with concepts that will pop-up once more in many other languages as well. For example, the concepts of sets, scopes of variables, constants, types, maps, list comprehensions and much more will be just as relevant (and sometimes even more) in Javascript as they are in Python.

<br>

# Key learning topics & resources for this part

<br>

## [CS50P - Et Cetera](https://cs50.harvard.edu/python/2022/weeks/9/) (4 hours)

**On docstrings/documentation:** writing documentation for code, while extremely useful, is anecdotally viewed as one of the things that developers are quite reluctant to do ("it’s tedious", "it’s not writing code!"). Recently, however, there is a lot of enthusiasm about using AI to either help write documentation or to have it write functions based on docstrings that you write yourself. Try both approaches to test these capabilities yourself.

<br>

## A Note on Using Familiar Techniques

At this point, you will have already learnt a lot of different techniques that you can use when coding. In fact, you know so many of them so that you can write complete, complex, working programs without using some of those techniques at all. As a simple example, you will have seen in the CS50 video that it’s relatively easy to implement a function that makes a list behave similarly to a set (i.e. it checks if a value is in the list and does nothing if it already exists). As another example, you can also quite easily avoid using command line arguments by simply having users input options inside the program. This may result in a rather common situation where a developer unconsciously chooses their own limited subset of techniques that they can use to achieve almost everything that they need, almost ignoring some of the other techniques.

What we suggest, however, is to consciously focus on regularly pushing yourself to use a wide variety of techniques when writing your code, constantly staying curious and versatile. You can do this as easily as just glancing over the video timestamp annotations in CS50P videos from time to time to remind yourself of the wide range of skills that you have already learned. This has multiple benefits:
- You will be able to quickly find more simple, effective solutions
- In some cases, the "default" set of techniques might not be enough and you will have forgotten all the different alternatives that you could use
- It will be much easier to work in teams where other developers might use a different set of techniques than you
- It will be extremely useful in interviews, where an interviewer might see something as default and basic for them, even though it can potentially be avoided often. You will avoid situations where not answering those questions could give a wrong impression to the interviewer.

<br>

## HackerRank practice (4 hours)
The following exercises will cover multiple topics and different difficulties, providing you with an opportunity for general coding practice.

[Classes: Dealing with Complex Numbers](https://www.hackerrank.com/challenges/class-1-dealing-with-complex-numbers/problem)
[Matrix script](https://www.hackerrank.com/challenges/matrix-script/problem)
[Validating UID](https://www.hackerrank.com/challenges/validating-uid/problem)
[Piling Up!](https://www.hackerrank.com/challenges/piling-up/problem)
[No Idea](https://www.hackerrank.com/challenges/no-idea/problem)
[Word Order](https://www.hackerrank.com/challenges/word-order/problem)

<br>


# Direction for further research (1+ hours):
- Can you access items in a set by indexing them? E.g. my_set[0]?
- What are some other standards and tools for writing documentation? How do they differ between different programming languages?
- What are the benefits of functional programming, compared to OOP besides the ones mentioned in CS50P? This can be quite a deep topic that developers debate a lot about!
- In Python, if you use functions like map() or filter(), will they necessarily have no side-effects?


Part 3: Introduction to Algorithms

<br>

In this part, we will move to CS50x – a different course by Harvard’s CS50 program which teaches introduction to Computer Science. Computer Science is a much broader term encompassing more than just web development, so some of the topics there are not as relevant for our particular course. The C language, for example, while quite fundamental in computer science, is not as important in web development these days. There are a couple of topics that are very useful to know for web developers, however.

The first one of such topics is algorithm analysis. While most junior web developers are unlikely to build complex algorithms yet, it is still very useful to get both an intuitive and a more technical understanding of what may cause significant inefficiencies so that you know what to avoid (and don’t accidentally build programs that take ridiculously long to run!). Also, you may encounter some basic questions regarding algorithms in job interviews as well, so it's worthwhile getting some basic knowledge in them.
<br>

# Key learning topics & resources for this part

<br>

## [CS50x – Algorithms](https://cs50.harvard.edu/college/2022/fall/weeks/0/) (0.2 hours)
Only section "Algorithms" (56:00-1:05:55) – this revises the first algorithm that you may already be aware of. It has a specific name, even though it was not mentioned yet in this video – binary search.

<br>

## [CS50 - Algorithms](https://cs50.harvard.edu/college/2022/fall/weeks/3/) (3 hours)
Part of this video will explain the algorithms in the programming language C. Do not worry – by now, your knowledge should be enough to read basic algorithms with just a bit of explanation in other languages as well. Furthermore, it will be quite interesting to compare how cumbersome some of the common functionalities are in C when compared to Python (e.g. string comparison). This will give an initial understanding of just how convenient Python is compared to many other languages. This does not mean that C is obsolete, however, far from it! If you would like, you can explore the benefits of different programming languages and you will find that C is still used a lot in various applications (e.g. Python itself was basically built using C!).

To be clear – in the parts that talk about C, do not focus too much on syntax or subtleties of how C works. As long as you are able to follow the logic, that is enough for this lecture. You are even advised to play these parts at a higher speed if you are short on time.

If you already know C from before and are in a hurry, you may even skip the part from 29:00 to 59:10.

## [Timing your Programs - cProfile](https://www.youtube.com/watch?v=BZzb_Wpag_M) (1 hour)
A popular tool in Python to analyze the speed of your programs (also known as *profiling*) is a library called cProfile. This video gives a great introduction on how to use it. It is very useful when you are writing more complex programs and are unsure about which parts of it need to be optimized. It is also one of the many possible ways to time specific functions that you want to analyze for time efficiency.

## Experimenting with Algorithms (6 hours)

Besides the 3 sorting algorithms you have just learned about (selection sort, bubble sort, merge sort) there is a fourth one that is just as popular – quicksort. In most cases, quicksort is actually the most efficient algorithm to sort lists. Since it is a bit more complex conceptually than the first 3 and since the algorithms lesson is introduced quite early in the CS50x course, quicksort is skipped there. However, since you now have a lot of experience with Python, this algorithm will not be a problem for you!

For this exercise, you will be implementing different sorting algorithms, quicksort included, and comparing their performance with different lists.

You'll be working with an existing Python codebase that generates different types of lists (random, sorted, reverse sorted, nearly sorted) and the beginning of the code for comparing how different sorting algorithms perform. You can download the Python file with this codebase **[here](https://drive.google.com/file/d/1sBRtxciQASAQ0AjofF_mFx3gGm1eOiTr/view?usp=sharing)**.

Your goal is to:
- Complete the three algorithm functions (you can create additional ones if you need them). First two should implement quicksort, but use a different pivot. The third algorithm can be anything that you choose – either one of the algorithms in the CS50 video or another one that you find. **You are strongly encouraged to try to write the algorithms yourself without looking at Python or other language implementations, except for pseudocode.**
- Expand the program to do a more detailed comparison of all the algorithms with different sets of lists.
- Try to make conclusions about the algorithm’s performance and how they relate to the lists being sorted. Discuss them in stand-ups and open sessions.

You can read an explanation of quicksort [here](https://dev.to/robogeek95/a-visual-giude-on-quicksort-algorithm-55df). Feel free to look into alternatives though. As you may notice in the [Wikipedia article](https://en.wikipedia.org/wiki/Quicksort), there’s quite a lot of room for optimisations! There is no need to go too deeply into it though – try to not spend more than the recommended hours on this exercise.

Once you've completed the main task, feel free to extend it in ways that spark your curiosity. Here are a few suggestions:

- Implement more sorting algorithms and add them to the comparison.
- Analyze how changing the size of the list affects the performance of the algorithms.
- Generate more types of lists to sort, such as lists with many duplicates or lists with a small range of values.
- Explore how to optimize your implementations for better performance.
- Compare your implementation with that of other learners. Remember though, you should compare the runtime of an algorithm on the same computer, so you will want to share your version of the algorithm or vice-versa.

Implementing and analyzing sorting algorithms is a classic exercise in algorithmic thinking and computational complexity analysis. It's not just about learning how these algorithms work, but also about understanding their strengths and weaknesses, and why certain algorithms might be preferred in different situations. By comparing the performance of different algorithms on various types of lists, you can observe how the structure of input data can affect the efficiency of an algorithm. You will also get a much more practical understanding of how BigO analysis translates into real runtime performance.

<br>

## Refactoring Your Code (2 hours)
Refactoring is the process of changing the code so that it works more efficiently and is more easy to read, yet has its functionality unchanged. It is a very common process when working with long-term projects. It is inevitable that some parts will be written hastily and suboptimally – whether it is inefficient, untidy, overly complex or verbose.

Before moving to the final project of this module, look back at the projects and exercises that you have completed so far. First of all, it should be exciting to see how far you have progressed! It should also make you feel that you could improve parts of that code significantly now. Practice refactoring by improving some of this previous code of yours.

Not only will this let you practice refactoring, but you may also find some patterns in your code that might make it particularly hard to maintain, understand and change in the future. By having to deal with it yourself, you will be much more mindful of it in the future when writing new code.



# Direction for further research (1+ hours):
- How many instructions would your program need to do in order for it to become noticeably slow? E.g. how many iterations of a simple addition/subtraction would a loop need to have in order for the program to not finish within 10 seconds?
- Python has search algorithms integrated into the language. E.g. you can use `x in my_list`. Which algorithm is used for this search?
- How would you use binary search in Python for a sorted list? E.g. you have a sorted list of integers and you want to use binary search to check if an element exists in that list with binary search. When might you want to use binary search in Python?
- Why would somebody wish to use the programming language C these days?
- What other sorting algorithms can you find?


Part 4: Python Capstone Project

<br>

Welcome to the first capstone project!

Capstone projects are a way for you to utilize everything that you have learned so far to showcase your skills and to build something unique! The project is deliberately open-ended, allowing every learner to work on what interests them the most. It is extremely similar to personal projects that many developers like to work on outside of their main work. Personal projects are a great way to demonstrate that you are passionate about programming and to constantly improve your skills. Furthermore, in many companies, recruiters will strongly prefer candidates that can show examples of such work on their public Git profiles. And finally, working on such projects can be very fun!

<br>

## Project description

First, brainstorm what program you want to build. You may want to think about solving a problem that either you or someone else has. Remember that you can make use of various libraries and APIs to build very powerful programs. The complexity of the project should be roughly similar to that of the graded project in the previous sprint.

If you have an idea that really interests you but which seems too big and complicated for this project, you can also try to build a minimalistic part of it. Ideally, it would still work and do at least a part of what the final program would do. Such minimal versions of projects are usually called MVPs – Minimum Viable Products.

We recommend spending a significant amount of time in this brainstorming phase (so the total time for this project will be more than that of the previous project). You can also consult other learners, JTLs and STLs on whether the scope of your idea is realistic for this project. The idea that you choose and how well you manage to put yourself in the role of the end-user will be evaluated as well.

Once you are happy with your idea, create an initial architecture plan for it. E.g. you can use pseudocode, diagrams, use-case descriptions or anything else that helps you. You can also create a list of tasks for yourself to complete (which you would then expand once you start working on the code). If you decide to use OOP, try thinking about what classes you will use and what their responsibilities will be. It does not need to be perfect – expect to find flaws and a need to update the architecture later. However, a plan like this will make the whole task much easier to approach.

Once you are happy with your initial plan, start working on the project. It might be useful to double-check what you have learned in this module regularly to ensure that you are using efficient tools and techniques for the problems that you are solving.

Also, since the code you will be writing for this project will be very different from that of other learners, the general rule of not sharing any pieces of code with other learners who have not yet completed this project does not apply. You can discuss your code with learners who are also working on this task and share feedback with each other. However, make sure that you are capable of reasonably explaining the logic behind your code during your corrections.

<br>

## Reviewer role
Different projects may require you to structure your presentation in different ways based on the imagined role of the reviewer. The goal is to practice interacting with different stakeholders that a developer will likely encounter in their careers.

In this project, imagine that you are presenting your personal project to a developer friend outside your organization.

<br>

## Project evaluation criteria
- The idea and implementation of the project is well-justified. It is possible to see why it could be useful to have a program like this.
- The program is easy and convenient to use
- The code is organized and well-structured
- Ability to read and explain the code during the correction.
- General understanding of topics from module 1.
- The quality of the project is high enough to be usable as a public portfolio item

During a task review, you may get asked questions that test your understanding of covered topics.

**Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)**


- Assume that you are working with a programming language that requires you to do all the searching and sorting yourself (i.e. with loops and conditional statements). In your program, you have a large list of unsorted items (which are sortable). In which cases (or maybe all of them?) would it be worth sorting the list before searching it?

<br>

# Submission

Submit your files to the GitHub repository of this project.

Read an in-depth guide about corrections here: https://turingcollege.atlassian.net/wiki/spaces/DLG/pages/537395951/Peer+expert+reviews+corrections

<br>

**Estimate average time to complete: 35 hours**


Module 2 - XXX
Module duration: ~X hours.
Each module 1 project (final part) takes about X hours to complete. There are X total projects in module 1.
Each of the X sprints in module 1 have X non-project parts. Each non-project part takes around X hours to complete.

Module goals








Sprint 1 - X
Sprint description


Sprint goals









Part 1:

Part description



Resources:




Direction for further research:









Part 2:

Part description



Resources:









Direction for further research:









Part 3:

Part description



Resources:









Direction for further research:







Part 4:

Part description



Resources:









Direction for further research:







Part 5: Sprint practical project


Project description


Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)








Project evaluation criteria









Submission and scheduling a correction
Before submitting your project, double check that you have saved your progress to your GitHub repository. Once you have done that, click the "Submit project" button in the Turing Platform. The platform then allows you to see the times when reviewers are available to have a call with you and review the project. Simply book a time that suits you. If there are no times available, feel free to message us in the #community_help channel on Discord — we will make sure that a reviewer adds a time for you.

You should also add times for reviewing others as well by clicking on "My Availability". Note that receiving a review costs 1 Correction Point. Once you run out of correction points, you will not be able to progress further until you review at least one other learner. Performing a review awards you with 2 correction points. We strongly suggest adding availability slots regularly as it might take some time until somebody books a review with you. Once somebody books a correction with you, you will be notified via email – make sure not to miss it and review the uploaded work beforehand!


Project expected time: 5 hours


Sprint 2 - X
Sprint description


Sprint goals









Part 1:

Part description



Resources:




Direction for further research:











Part 2:

Part description



Resources:









Direction for further research:









Part 3:

Part description



Resources:









Direction for further research:







Part 4:

Part description



Resources:









Direction for further research:







Part 5: Sprint practical project


Project description


Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)








Project evaluation criteria









Submission and scheduling a correction
Before submitting your project, double check that you have saved your progress to your GitHub repository. Once you have done that, click the "Submit project" button in the Turing Platform. The platform then allows you to see the times when reviewers are available to have a call with you and review the project. Simply book a time that suits you. If there are no times available, feel free to message us in the #community_help channel on Discord — we will make sure that a reviewer adds a time for you.

You should also add times for reviewing others as well by clicking on "My Availability". Note that receiving a review costs 1 Correction Point. Once you run out of correction points, you will not be able to progress further until you review at least one other learner. Performing a review awards you with 2 correction points. We strongly suggest adding availability slots regularly as it might take some time until somebody books a review with you. Once somebody books a correction with you, you will be notified via email – make sure not to miss it and review the uploaded work beforehand!


Project expected time: 5 hours

SPRINT TEMPLATE
Part 1: <name>

<br>

<part description>

<br>

# Key learning topics & resources for this part

<br>

## [title](link) (X hours)
<comment>

<br>

## [title](link) (X hours)
<comment>

<br>

# Direction for further research (1+ hours):
- <direction>

Part 2: <name>

<br>

<part description>

<br>

# Key learning topics & resources for this part

<br>

## [title](link) (X hours)
<comment>

<br>

## [title](link) (X hours)
<comment>

<br>

# Direction for further research (1+ hours):
- <direction>

Part 3: <name>

<br>

<part description>

<br>

# Key learning topics & resources for this part

<br>

## [title](link) (X hours)
<comment>

<br>

## [title](link) (X hours)
<comment>

<br>

# Direction for further research (1+ hours):
- <direction>

Part 4: <name>

<br>

<part description>

<br>

# Key learning topics & resources for this part

<br>

## [title](link) (X hours)
<comment>

<br>

## [title](link) (X hours)
<comment>

<br>

# Direction for further research (1+ hours):
- <direction>

Part 5: <name>

<br>

<part description>

<br>

## Project description

<project description>

## The requirements you are given to implement are as follows:
- <list requirements>

<additional comments>

<br>

## Reviewer role
Different projects may require you to structure your presentation in different ways based on the imagined role of the reviewer. The goal is to practice interacting with different stakeholders that a developer will likely encounter in their careers.

<description of role>

<br>

## Project evaluation criteria
- <list criteria>

During a task review, you may get asked questions that test your understanding of covered topics.

**Sample questions for a reviewer to ask (a reviewer is encouraged and expected to think of more, however!)**


- <list questions>

<br>

# Submission

To submit the project and allow the reviewer to view your work beforehand, go to your GitHub repository by clicking on the GitHub icon above. Next, select "Add File"->"Upload Files". Choose the files you worked on to upload them, then click the green "Commit changes" button.
Note: the repository for this project is different from the one you used in the last project! Make sure you are using the correct one by clicking on the GitHub icon in this project’s page.
Once you have completed all the steps of the project and uploaded your work, go to the Turing Platform and click the "Submit Project" button to complete it. The platform then allows you to see the times when reviewers are available to have a call with you and review the project. Simply book a time that suits you. If there are no times available, feel free to write a message in the #wd_correction_scheduling channel on Discord.
Read an in-depth guide about corrections here: https://turingcollege.atlassian.net/wiki/spaces/DLG/pages/537395951/Peer+expert+reviews+corrections

<br>

**Estimate average time to complete: xx hours**
